# 銀行アプリケーションのオブジェクト指向設計ポイント

## 1. 継承と抽象化

### 実装
- `Account`を基底クラスとし、`SavingsAccount`と`CheckingAccount`をサブクラスとして実装。

### 理由
- 口座番号や残高といった共通要素を`Account`クラスに集約することで、コードの重複を避けられる。
- 預金口座や当座預金口座など、異なる種類の口座を容易に追加できる柔軟な構造を実現できる。

## 2. カプセル化

### 実装
- 口座残高などの重要なデータをプライベート変数として定義。
- アクセサメソッドを通じてのみデータの取得や変更を許可。

### 理由
- 残高の直接操作を防ぐことで、不正な変更や予期せぬエラーを防止できる。
- 将来的に残高の計算方法や保存方法を変更する際に、外部のコードに影響を与えずに内部実装を変更できる。

## 3. ポリモーフィズム

### 実装
- `withdraw`メソッドを各サブクラスでオーバーライド。
- `Bank`クラスで異なる種類の口座を統一的に扱う。

### 理由
- 普通預金と当座預金で出金処理が異なる（例：当座貸越の有無）場合でも、同じメソッド名で異なる処理を実行できる。
- 新しい口座タイプを追加する際に、既存のコードを変更せずに新しい振る舞いを追加できる。

## 4. 単一責任の原則

### 実装
- `Account`クラスは口座の基本操作のみを担当。
- `Bank`クラスが口座の作成と管理を担当。

### 理由
- 口座の操作と銀行の管理を分離することで、それぞれの変更が他方に影響を与えにくくなる。
- 例えば、口座の利息計算ロジックを変更する際に、銀行の管理ロジックを変更する必要がなくなる。

## 5. 依存性の注入

### 実装
- `Bank`クラスのメソッドが`Account`オブジェクトを引数として受け取る。

### 理由
- 特定の口座タイプに依存せず、新しい口座タイプが追加されても`Bank`クラスの変更が最小限で済む。
- テスト時に、実際の`Account`オブジェクトの代わりにモックオブジェクトを使用しやすくなる。

## 6. インターフェースの一貫性

### 実装
- すべての`Account`サブクラスが同じメソッド（`deposit`, `withdraw`, `balance`）を持つ。

### 理由
- どの種類の口座でも同じ方法で操作できるため、使用する側のコードがシンプルになる。
- 新しい口座タイプを追加する際に、既存の操作方法を踏襲するだけで済み、システム全体の一貫性が保たれる。

## 7. ファクトリーメソッドパターン

### 実装
- `Bank`クラス内で口座の種類に応じて適切な`Account`サブクラスのインスタンスを生成。

### 理由
- 口座の生成ロジックを一箇所にまとめることで、新しい口座タイプの追加や既存タイプの変更が容易になる。
- 口座の生成に関する複雑なロジックを`Bank`クラスに隠蔽することで、使用する側のコードをシンプルに保てる。

## 8. 拡張性の考慮

### 実装
- 各クラスが明確に定義された責任を持ち、相互に疎結合な設計。

### 理由
- 例えば、口座間送金機能を追加する際に、既存のクラスへの影響を最小限に抑えながら新しい機能を実装できる。
- 将来的に、モバイルバンキングや暗号通貨対応など、新しい要件が発生した場合でも、既存のシステムを大きく変更せずに対応できる。